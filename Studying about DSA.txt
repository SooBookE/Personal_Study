/* 20231226 */

[[ DSA ( Data Structures and Algorithms ) ]] - References : geeksforgeeks.org

개요 :  DSA( Data Structures and Algorithms )는 완벽히 분류되어 있지만,
        서로 연관성이 있는 두 토픽인 자료 구조( Data Structures )와 알고리즘( Algorithms )을 일컫습니다.
        DSA는 CS를 배우는 사람들이 필수적으로 익혀야하는 가장 중요한 요소입니다.

자료 구조 : 데이터를 효율적이고 효과적이게 쓸 수 있도록, 기기에 데이터의 적재와 분류하는 방식을 지칭합니다.
            시간 복잡도와 공간 복잡도를 최소화하는 것을 자료 구조 사용 전에 선행해야합니다.

알고리즘 :  특정 상황의 문제 해결이나, 계산 등에 사용되는 절차, 혹은 잘 정의된 구조들의 집합입니다.
            특정 업무를 해결하는 절차들의 집합이라고 생각하면 되겠습니다.

[[ 학습 과정 ]]

1. 시간 복잡도, 공간 복잡도에 관해 학습한다.
2. 기본 자료 구조를 학습한다.
3. 기본 알고리즘을 학습한다.
4. DSA 문제 풀이를 연습한다.

====================================================================================================

[[ 1. 복잡도 학습하기 ]]

DSA의 발발의 주요 계기인 효율적이고 효과적인 문제 해결을 위해, "시간 복잡도"와 "공간 복잡도"의 개념이 생겼습니다.

1. 시간 복잡도 : 코드 수행에 필요한 시간의 총량을 측정하기 위해 사용합니다.
2. 공간 복잡도 : 코드의 기능들을 성공적으로 수행하기 위해 필요한 공간들의 총량을 지칭합니다.
                또한, 자료 구조 외의 작업 수행에 사용되는 보조 공간( Auxiliary Space )이라는
                용어도 기억해야 할 요소입니다.

이에 더해, 코드 수행에 필요한 시간은 다음과 같은 몇몇 요소들에 의해 좌우됩니다.
 • 프로그램 내에서 실행되는 작업의 수.
 • 장치의 처리 속도.
 • 데이터 전달 속도.( ex. 온라인 플랫폼에서 코드 수행 등의 상황 )

이런 사항들과 무관하게 효율성을 측정하기 위해, "점근 표기법( Asymptotic Notation )"을 사용합니다.

점근 표기법( Asymptotic Notation )은 코드 수행이 필요하지 않고, 입력 크기에 따른 필요 시간을
측정하는 수학적인 도구입니다.
시스템 의존적인 상수와 관계 없이, 전체 프로그램에서 수행되는 모듈 작업의 개수와 연관성을 가집니다.

다음의 세 가지의 점근 표기법이 대표적으로 사용됩니다.
 • Big O Notation( O ) - 최악의 케이스를 설명할 때 사용합니다.
 • Omega Notation( Ω ) - 최상의 케이스를 설명할 때 사용합니다.
 • Theta Notation( θ ) - 알고리즘의 평균 복잡도를 설명할 때 사용합니다.

/* 20231228 */

코드 분석에서 가장 많이 사용되는 표기법은 Big-O 표기법으로, "코드 실행 시간"이나 "입력 크기에 따라
사용되는 메모리 양"의 상한성을 제시합니다.

----------------------------------------------------------------------------------------------------
        [Big-O 표기법]
        Big-O 표기법을 통해, 알고리즘의 복잡성을 표기할 수 있습니다.
        
        크기가 N일 때 :
                • 상수 시간이 소요되는 함수 혹은 작업은 차수가 "1"입니다. : O(1)
                • 선형적으로 시간이 소요되는 함수 혹은 작업은 차수가 "N"입니다. : O(N)
                • 2차 함수 형태로 시간이 소요되는 함수 혹은 작업은 차수가 "N^2"입니다. : O(N^2)
        
        정의 :  자연수 집합의 함수 g와 f가 있습니다.
                모든 n>=n0에 대해 f(n)<=cg(n)인 양수인 상수 c와 자연수 n0가 존재하면,
                함수 f는 O(g)라고 정의합니다.
        
        참고 : O(g)는 집합입니다.

        f(n)=O(g(n))
        는
        f(n)∈O(g(n))
        를 의미하지 않습니다.

        Big-O 표기법으로 런타임 분석 시의 일반적인 절차는 다음과 같습니다.
                1. 입력이 무엇인지, n이 무엇을 나타내는지 탐색하기.
                2. 최대 작업 수를 표현하면 알고리즘은 n의 관점에서 수행됩니다.
                3. 최고차항을 제외하고 모두 제거합니다.
                4. 모든 상수 요소를 제거합니다.


/* 20231230 */

        Big-O 표기법 분석의 유용한 속성 몇 가지는 다음과 같습니다.
                상수 곱셈 : f(n) = c*g(n)이면, O(f(n))=O(g(n))
                                단, c는 0이 아닌 상수.
        
        자세한 건 나중에 알아보자 ㅎㅎ..
----------------------------------------------------------------------------------------------------

[[ 2. 데이터 구조 배우기 ]]

DSA의 주제는 두 부분으로 구성됩니다.

• 데이터 구조
• 알고리즘

서로 다르지만, 밀접하게 연관되어 있는 주제이므로, 올바른 순서로 학습하는게 중요합니다.

데이터 구조를 먼저 학습한 다음, 해당 데이터 구조에서 관련성과 중요도가 높은
알고리즘을 학습하도록 하겠습니다.



1. 배열

가장 기본적이고, 중요한 데이터 구조입니다. 선형 구조이며, 요소에 연속적으로 메모리를 할당하는
동종 데이터의 모음입니다. 연속적인 메모리 할당 구조이므로, 일정 시간 내로 배열의 모든 요소에
접근 가능합니다. 각 배열의 요소에는 해당 위치에 대한 인덱스 번호가 주어집니다.

배열 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726162247/Array-data-structure.png

배열에 관해 배워야 할 몇 가지 주제는 다음과 같습니다.
 • 배열 역방향  - 배열의 요소를 역방향으로 이동하는 것을 뜻합니다. 예를 들어,
                Input   : arr[] = {1, 2, 3}
                Output  : arr[] = {3, 2, 1}
                와 같이 동작합니다.
                
 • 배열 회전    - 배열 요소를 원형 방식으로 이동하는 것을 뜻합니다. 예를 들어,
                Input   : arr[] = {1, 2, 3, 4, 5}
                Output  : arr[] = {5, 1, 2, 3, 4}
                와 같이 동작합니다.

 • 배열 재배열  - 일부 조건이나 작업에 따라 요소의 초기 순서가 변경되는 것을 뜻합니다.

 • 배열 범위 쿼리 - 다양한 요소에 대해 작업을 수행해야 할 때 사용되는 함수를 뜻합니다.
 
 • 다차원 배열  - 둘 이상의 차원을 갖는 배열을 뜻합니다. 가장 많이 사용되는 것은
                행렬이라고도 불리는 2차원 배열입니다.

 • Kadane 알고리즘

 • 네덜란드 국기 알고리즘



2. 문자열 데이터 구조

문자열도 배열의 한 유형입니다. 그러나 문자열의 마지막 문자는 Null 문자로,
문자열의 끝을 의미한다는 점이 특징입니다. 또한, 두 문자열을 연결하기 위해 사용하는
"순차적 연결"( Concatenation ) 등의 고유한 작업이 존재합니다.

문자열 이미지 링크 => https://media.geeksforgeeks.org/wp-content/uploads/20220820132424/Strings.png

/* 20240101 */ Geeks for Geeks에서 각 챕터마다 연습 문제들을 풀어볼 수 있습니다!

문자열에 대해 알아야 할 몇 가지 개념은 다음과 같습니다.
 • 하위 시퀀스 및 하위 문자열 - 하위 시퀀스는 문자열 안에서 개별적으로 존재할 수 있는 시퀀스로,
                                같은 요소의 순서만 바꾼 중복을 제외해서 도출될 수 있는 최소 인자들입니다.
                                크기 n의 시퀀스에 대해 총 ((2^n)-1)개의 하위 시퀀스를 가질 수 있다고 말할 수 있습니다.
                                ( 중복 요소의 유무 때문에 절대적이지 않습니다. )

하위 시퀀스 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220624174644/Subsequences-of-a-String-1024x577.jpg

                                하위 문자열은 문자열 내부의 끊긴 부분 없이 연결된 문자열을 지칭합니다.
                                크기가 n인 문자열의 경우, 비어 있지 않은 하위 문자열이 n*(n+1)/2개 있습니다.

하위 문자열 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/Substring-min.png

 • 문자열의 역방향 및 회전 - 역방향은 문자가 역순으로 첫째 문자부터 채워지도록 변환함을 의미합니다. 회전은 주어진 숫자만큼 문자열이 이동하면 순서가
                                변환하는 것으로, 좌측/우측 회전으로 분류되어 있습니다.
                                예시로 좌측 회전은 주어진 숫자만큼 문자열이 좌측으로 이동하고,
                                주어진 숫자만큼 문자열의 크기를 넘어간 좌측 요소가 문자열의 비어진 마지막 부분으로 이동하게 됩니다.

 • 이진 문자열 - 텍스트 형식이 아닌 이진( 0, 1 ) 형식으로 표현되는 데이터를 저장하는데 사용합니다.
                데이터 베이스에서 사용되는 가장 일반적인 유형은 다음과 같습니다.

                        • BINARY - 고정 길이 이진 데이터를 저장하는데 사용합니다. 열( Column )에 들어가는 데이터의 크기는 항상 동일해야 하며, 그 크기는
                                        테이블 생성 시에 정의되어야 합니다. 예를 들어, BINARY(10)인 경우 길이가 정확히 10바이트인 이진 문자열만 보유할 수 있습니다.

                        • VARBINARY - BINARY 타입과 유사하지만, 가변 길이 데이터를 허용하는 형식입니다. 따로 열 크기를 정의할 필요가 없습니다.
                                        예를 들어( ? ), VARBINARY 열은 0~65,535바이트( 2^16 ) 크기의 이진 문자열을 저장할 수 있습니다.

                        • BLOB( Binary Large Object ) - 이미지, 오디오, 비디오 파일 등의 대규모 이진 데이터 개체를 저장하는데 사용합니다. 저장할 데이터의 크기가
                                                        BINARY나 VARBINARY 데이터 유형에서 허용하는 크기를 벗어난 경우 사용합니다. BLOB의 열은 어떤 크기의 이진 데이터도
                                                        담을 수 있기 때문에, 너무 커서 테이블에 직접 들어갈 수 없는 파일을 저장하는데 사용합니다.

                이진 문자열의 몇 가지 중요한 속성은 다음과 같습니다.

                        • 길이 - 이진 문자열의 비트 양에 따라 길이가 결정됩니다.
                        • 연결 - 두 개 이상의 이진 문자열을 순서대로 연결할 수 있습니다.
                        • 하위 문자열 - 이진 문자열은 하위 문자열로 나눠질 수 있습니다.
                        • 접두사 및 접미사 - 접두사는 이진 문자열의 첫 단일 하위 문자열입니다. 접미사는 마지막 단일 하위 문자열입니다.
                        • 해밍 거리( Hamming Distance ) - 같은 길이의 두 이진 문자열에서 다른 요소를 가진 인덱스의 개수를 의미합니다.
                        • 정규 언어( Regular Language ) - 모든 이진 문자열의 집합은 정규 언어로, 이는 *유한 상태 기계나
                                                                *정규 표현식( Regex )에 사용될 수 있습니다.
                                        *유한 상태 기계( Finite-State Machine, FSM ) : 유한 오토마톤( Finite Automaton, FA; 복수형은 유한 오토마타 Finite Automata )
                                                                                        이라고도 불리는 유한 상태 기계는 컴퓨터 프로그램과 전자 논리 회로를 설계하는데
                                                                                        사용되는 수학적 모델입니다.
                                        *정규 표현식( Regular Expression ) : 특정한 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어로서, 많은 텍스트 편집기와
                                                                                프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있습니다.
                        • 이진 산술( Binary Arithmetic ) - 각 비트가 2의 거듭제곱에 해당하는 이진 산술에서 이진 문자열을 사용해 정수를 표현할 수 있습니다.

 • 회문( Palindrome ) - 회문 문자열은 문자열 중심으로부터 같은 거리에 있는 요소가 동일한 문자열입니다. 토마토, 스위스, 기러기, 우영우 같은 느낌입니다!

 • 사전식 패턴( Lexicographic Pattern ) - ASCII 코드 기반의 값을 갖거나, 사전 순서로 정렬된 패턴으로 요소를 찾는 것을 의미합니다. 예를 들어, "acb"라는 문자열이 입력되면,
                                                해당 문자열의 요소로 만들 수 있는 사전 순서의 경우는 다음과 같습니다.
                                                "abc", "acb", "bac", "bca", "cab", "cba"
                                                여기에서 "acb"의 순위는 2임을 알 수 있습니다.

 • 패턴 검색 - 패턴 검색은 문자열에서 지정된 패턴을 검색하는 것을 의미합니다. 이는 문자열 항목의 고급 주제입니다.



3. 연결 리스트( Linked Lists )

위의 자료 구조들과 마찬가지로 선형을 띄고 있습니다. 하지만 배열과 다르게 연속된 메모리 위치에 데이터가 할당되지 않습니다. 연결 리스트의 각 노드는 임의의 메모리 공간에 할당되고,
이전 노드는 현재 노드에 대한 포인터를 제공하게 됩니다. 이런 특징에 의해, 모든 노드에 대한 직접적인 접근은 불가하며, 연결 리스트의 크기는 언제든지 동적으로 조절 가능합니다.

( 깨알 영어 공부 : i.e. 라틴어 id est의 약자로, "다시 말해서"라는 뜻을 가집니다. )
( 깨알 영어 공부 : e.g. 라틴어 exempli gratia의 약자로, "예를 들면"이라는 뜻을 가집니다. )

연결 리스트 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726162542/Linked-List-Data-Structure.png

연결 리스트에서 중요하게 다루는 주제는 다음과 같습니다.
 • 단일 연결 리스트( Single Linked List ) - 연결 목록의 각 노드가 다음 노드만을 가리킵니다.

 단일 연결 리스트 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/uploads/20220816144425/LLdrawio.png

 • 순환 연결 리스트( Circular Linked List ) - 단일 연결 리스트와 동일하나, 마지막 노드가 연결 목록의 첫 노드를 가리킵니다.

 순환 연결 리스트 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/uploads/CircularLinkeList.png

 • 이중 연결 리스트( Doubly Linked List ) - 연결 리스트의 각 노드마다 두 개의 포인터가 존재하며, 각각 이전 노드와 다음 노드를 가리킵니다.

 이중 연결 리스트 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2014/03/DLL1.png



4. 행렬/그리드( Matrix/Grid )

행렬( Matrix )은 행과 열로 배열된 숫자의 모음입니다. 예시로 9개의 요소가 있는 행렬 M은 다음과 같이 표현됩니다.

행렬 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/uploads/matrix-9.png

행렬 M 3행 3열로 이루어져 있습니다. 행렬의 각 요소는 행/열의 번호를 통해 접근할 수 있습니다. 예를 들어, 이미지에서 M[2][3]==6 입니다.
( 보통 인덱스는 0부터 시작하는 것이 일반적이며, 해당 아티클에서는 독자의 이해를 돕기 위해 1부터 인덱싱한 것 같습니다. )

행렬( 또는 2차원 배열 )을 선언하는 방법은 1차원 배열의 방법과 유사합니다.

int arr[행의 개수][열의 개수];

예를 들어, 3행 3열로 이루어진 행렬 "x"는 다음 이미지와 같이 생성됩니다.

행렬 예시 이미지 링크2 => https://media.geeksforgeeks.org/wp-content/uploads/20221010013429/twod-660x252.png

행렬( 또는 그리드 )를 초기화하는 방법은 두 가지가 있습니다.
        방법 1 : int arr[4][3]={1, 2, 3, 4, 5, 6, 20, 80, 90, 100, 110, 120};
        방법 2 : int arr[4][3]={{1, 2, 3}, {4, 5, 6}, {20, 80, 90}, {100, 110, 120}};
두 가지 초기화 방법 중, 둘째 방법이 더 직관적이면서 이해하기 쉽기 때문에 자주 사용됩니다.

앞서 언급한 바와 같이, 행렬의 각 요소는 행/열의 인덱스 번호를 통해 접근할 수 있습니다. 아래 이미지의 행렬 "x"의 요소 "1"은 x[2][1]==1 입니다.

행렬 예시 이미지 링크3 => https://media.geeksforgeeks.org/wp-content/uploads/20221010013158/2Darray.png

( 해당 예시 이미지에서는 인덱스를 0부터 책정했습니다. )



5. 스택( Stack )

좀 더 복잡한 데이터 구조인, 스택( Stack )과 큐( Queue )에 대해 알아봅시다.

스택은 작업이나 데이터가 특정 순서에 따라 출력되도록 하는 데이터 구조입니다. LIFO( Last-In, First-Out ){ == FILO( First-In, Last-Out ) }의 순서를 따릅니다.

스택 예시 이미지 링크 => https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165552/Stack-Data-Structure.png

스택이 복잡한 데이터 구조로 간주되는 이유는, 배열이나 연결 리스트 등을 사용해 스택의 특징과 특성을 구현하기 때문입니다.

스택은 간단하게 프링글스 통에 감자칩을 담고 꺼내는 상황을 상상하시면 됩니다. 처음 넣었던 감자칩은 맨 밑으로 깔리게 되고, 마지막 넣은 감자칩이 가장 먼저 꺼내지게 됩니다.
이러한 LIFO 방식은 가장 최신의 정보를 사용해야 할 경우, 스택과 변형 스택과 같은 데이터 구조를 사용하거나, 배열이나 데이터 버퍼에서 데이터를 추출할 때 사용합니다.